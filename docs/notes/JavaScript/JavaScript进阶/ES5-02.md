---
title: 内存
date: 2019-12-17
tags:
 - JavaScript进阶
 - 笔记
categories: 
 - 笔记
---

# 内存

## 垃圾回收机制
### 1. 引用计数法

语言引擎有一张"引用表"，保存着所有值的引用次数，如果一个值的引用次数为0，表示该值不再用到，因此可以将这块内存释放。

<div align="left">
    <img src="https://cdn.jsdelivr.net/gh/Au-c/PicGo@main/notes/markdownPic/20201028194518.png" width="300"></img>
</div>
如图，左下角的两个值被引用次数为0，会被释放内存。

**示例：**
- `const arr = [1, 2, 3, 4];`后面数组[1, 2, 3 ,4]被arr这个变量引用一次，所以不会被释放内存。
- 如果想要手动释放，在后面手动清除该引用即可：`arr = null`，此时，变量arr不再引用数组，数组[1, 2, 3, 4]引用次数为0，内存被释放。

### 2. 标记清除法

垃圾收集器工作原理：
  - 给所有变量打上标记。
  - 去除环境中的变量以及被环境中变量可以访问的变量的标记。
  - 之后还拥有标记的变量将会被垃圾收集器收集，并释放内存。

解析：
- 保留的变量：
    - 以当前环境中的所有变量为root，其可访问到的所有变量都被保留
    - 层层递进，直到找不到可以访问的变量为止，这些变量都会被保留。
<div align="left">
    <img src="https://cdn.jsdelivr.net/gh/Au-c/PicGo@main/notes/markdownPic/20201028202247.png" width="500"></img>
</div>

### 3. 优化建议
- **分代收集**：将变量分为两组，“旧的”和“新的”，那些长期存活的变量归到“旧的”一组，被垃圾收集器检测的频率少；那些在执行流中新出现的变量，都将被归到"新的"一组中，检查频率多。
- **闲时收集**：垃圾收集器只会在CPU空闲时运行。
- **增量收集**：原来的垃圾收集器会从根开始，找到所有可以引用、访问的变量，当路径很深时，很多时，可能会需要一些时间，这时使用增量收集优化，将该过程分成几部分来做，然后再对这几部分进行逐一处理，用多段小的延迟，避免一段大的延迟。

## 内存泄漏
- 程序运行向操作系统申请内存，为了维持持续运行的服务进程，降低性能的损耗，必须把不再用到的内存释放。
- 当不再用到的内存没有被释放时，就会发生内存泄漏。