(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{553:function(t,a,r){"use strict";r.r(a);var _=r(5),v=Object(_.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"内存"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内存"}},[t._v("#")]),t._v(" 内存")]),t._v(" "),r("h2",{attrs:{id:"垃圾回收机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收机制"}},[t._v("#")]),t._v(" 垃圾回收机制")]),t._v(" "),r("h3",{attrs:{id:"_1-引用计数法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-引用计数法"}},[t._v("#")]),t._v(" 1. 引用计数法")]),t._v(" "),r("p",[t._v('语言引擎有一张"引用表"，保存着所有值的引用次数，如果一个值的引用次数为0，表示该值不再用到，因此可以将这块内存释放。')]),t._v(" "),r("div",{attrs:{align:"left"}},[r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Au-c/PicGo@main/notes/markdownPic/20201028194518.png",width:"300"}})]),t._v("\n如图，左下角的两个值被引用次数为0，会被释放内存。\n"),r("p",[r("strong",[t._v("示例：")])]),t._v(" "),r("ul",[r("li",[r("code",[t._v("const arr = [1, 2, 3, 4];")]),t._v("后面数组[1, 2, 3 ,4]被arr这个变量引用一次，所以不会被释放内存。")]),t._v(" "),r("li",[t._v("如果想要手动释放，在后面手动清除该引用即可："),r("code",[t._v("arr = null")]),t._v("，此时，变量arr不再引用数组，数组[1, 2, 3, 4]引用次数为0，内存被释放。")])]),t._v(" "),r("h3",{attrs:{id:"_2-标记清除法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-标记清除法"}},[t._v("#")]),t._v(" 2. 标记清除法")]),t._v(" "),r("p",[t._v("垃圾收集器工作原理：")]),t._v(" "),r("ul",[r("li",[t._v("给所有变量打上标记。")]),t._v(" "),r("li",[t._v("去除环境中的变量以及被环境中变量可以访问的变量的标记。")]),t._v(" "),r("li",[t._v("之后还拥有标记的变量将会被垃圾收集器收集，并释放内存。")])]),t._v(" "),r("p",[t._v("解析：")]),t._v(" "),r("ul",[r("li",[t._v("保留的变量：\n"),r("ul",[r("li",[t._v("以当前环境中的所有变量为root，其可访问到的所有变量都被保留")]),t._v(" "),r("li",[t._v("层层递进，直到找不到可以访问的变量为止，这些变量都会被保留。\n"),r("div",{attrs:{align:"left"}},[r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Au-c/PicGo@main/notes/markdownPic/20201028202247.png",width:"500"}})])])])])]),t._v(" "),r("h3",{attrs:{id:"_3-优化建议"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-优化建议"}},[t._v("#")]),t._v(" 3. 优化建议")]),t._v(" "),r("ul",[r("li",[r("strong",[t._v("分代收集")]),t._v('：将变量分为两组，“旧的”和“新的”，那些长期存活的变量归到“旧的”一组，被垃圾收集器检测的频率少；那些在执行流中新出现的变量，都将被归到"新的"一组中，检查频率多。')]),t._v(" "),r("li",[r("strong",[t._v("闲时收集")]),t._v("：垃圾收集器只会在CPU空闲时运行。")]),t._v(" "),r("li",[r("strong",[t._v("增量收集")]),t._v("：原来的垃圾收集器会从根开始，找到所有可以引用、访问的变量，当路径很深时，很多时，可能会需要一些时间，这时使用增量收集优化，将该过程分成几部分来做，然后再对这几部分进行逐一处理，用多段小的延迟，避免一段大的延迟。")])]),t._v(" "),r("h2",{attrs:{id:"内存泄漏"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内存泄漏"}},[t._v("#")]),t._v(" 内存泄漏")]),t._v(" "),r("ul",[r("li",[t._v("程序运行向操作系统申请内存，为了维持持续运行的服务进程，降低性能的损耗，必须把不再用到的内存释放。")]),t._v(" "),r("li",[t._v("当不再用到的内存没有被释放时，就会发生内存泄漏。")])])])}),[],!1,null,null,null);a.default=v.exports}}]);