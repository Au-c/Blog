(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{554:function(v,t,_){"use strict";_.r(t);var a=_(5),i=Object(a.a)({},(function(){var v=this,t=v.$createElement,_=v._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"javascript-运行机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#javascript-运行机制"}},[v._v("#")]),v._v(" JavaScript 运行机制")]),v._v(" "),_("h2",{attrs:{id:"单线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#单线程"}},[v._v("#")]),v._v(" 单线程")]),v._v(" "),_("p",[v._v("JavaScript语言的一大特色就是单线程。")]),v._v(" "),_("blockquote",[_("p",[v._v("使用多线程可以提高效率，为什么不用多线程？\n提供一个场景：如果为多线程，一个线程添加DOM，一个线程删除DOM，浏览器以哪个线程为准？\n为了避免问题复杂化，单线程是JS的核心。")])]),v._v(" "),_("p",[v._v("为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JS创建多个线程，分为主线程与子线程，子线程完全由主线程控制，且不可以操作DOM，所以JS本质上还是单线程。")]),v._v(" "),_("h2",{attrs:{id:"任务队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#任务队列"}},[v._v("#")]),v._v(" 任务队列")]),v._v(" "),_("p",[v._v("在线程中执行一个一个的任务，是一个宏概念。")]),v._v(" "),_("p",[_("strong",[v._v("栈与队列")]),v._v("：")]),v._v(" "),_("ul",[_("li",[v._v("栈：先入后出的数据结构。")]),v._v(" "),_("li",[v._v("队列：先入先出的数据结构。")])]),v._v(" "),_("p",[_("strong",[v._v("JS任务分为两种")]),v._v("：")]),v._v(" "),_("ul",[_("li",[v._v("同步任务：在执行栈中执行的任务。")]),v._v(" "),_("li",[v._v("异步任务：不进入主线程，放入任务队列的任务。")])]),v._v(" "),_("p",[_("strong",[v._v("任务的执行流程")]),v._v("：")]),v._v(" "),_("ol",[_("li",[v._v("在主线程上执行同步任务，形成执行栈。")]),v._v(" "),_("li",[v._v("如果检索到是异步任务，在任务队列中放置一个事件等待，挂起其回调函数。")]),v._v(" "),_("li",[v._v("执行完执行栈中全部的同步任务(此时空闲)，系统开始按照队列上事件的排列顺序(先入先出)一个个读取，放入执行栈执行(执行其对应的回调函数)。")]),v._v(" "),_("li",[v._v("主线程不断重复上三步。\n"),_("div",{attrs:{align:"left"}},[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Au-c/PicGo@main/notes/markdownPic/20201030230655.png",width:"500"}})])])]),v._v(" "),_("blockquote",[_("ul",[_("li",[v._v('只要主线程空了(空闲了)，就会去读取"任务队列"，这就是JavaScript的运行机制。这个过程会不断重复。')]),v._v(" "),_("li",[v._v('但是，由于存在后文提到的"定时器"功能，'),_("strong",[v._v("主线程首先要检查一下执行时间")]),v._v("，某些事件只有到了规定的时间，才能返回主线程。")]),v._v(" "),_("li",[v._v("异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。")])])]),v._v(" "),_("p",[_("strong",[v._v("定时器异步任务")]),v._v(" "),_("code",[v._v("setTimeout()")]),v._v("与"),_("code",[v._v("setInterval()")]),v._v("，第二个参数为延时执行事件。")]),v._v(" "),_("ol",[_("li",[v._v("不管延时设置多低必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数")]),v._v(" "),_("li",[v._v("HTML5规定第二个参数最低4毫秒，低于自动加到这个值。")]),v._v(" "),_("li",[v._v("要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在指定的时间执行。")])]),v._v(" "),_("h2",{attrs:{id:"event-loop"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#event-loop"}},[v._v("#")]),v._v(" Event Loop")]),v._v(" "),_("p",[v._v('主线程清空后总会去"任务队列"中读取事件，不断循环，整个运行机制称为Event Loop（事件循环）。\n')]),_("div",{attrs:{align:"left"}},[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Au-c/PicGo@main/notes/markdownPic/20201030233130.png",width:"500"}})]),_("p"),v._v(" "),_("ol",[_("li",[v._v("主线程运行时，产生堆栈。")]),v._v(" "),_("li",[v._v("栈中执行时，遇到需要异步的代码，栈中代码调用API，在任务队列中加入各种事件。")]),v._v(" "),_("li",[v._v("执行完栈中代码(空闲了)，主线程读取任务队列，依次执行那些事件对应回调函数。")])])])}),[],!1,null,null,null);t.default=i.exports}}]);